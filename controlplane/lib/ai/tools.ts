import type { ConvexHttpClient } from 'convex/browser';
import { tool, type UIMessageStreamWriter } from 'ai';
import { z } from 'zod';
import { api } from '@/convex/_generated/api';
import type { Id } from '@/convex/_generated/dataModel';
import { streamArtifactDraft } from '@/lib/ai/artifacts';
import type { ChatMessage } from '@/lib/chat/types';

type BuildChatToolsInput = {
  client: ConvexHttpClient;
  conversationId: Id<'conversations'>;
  selectedChatModel?: string;
  writer: UIMessageStreamWriter<ChatMessage>;
};

function createArtifactTools({
  client,
  conversationId,
  selectedChatModel,
  writer,
}: BuildChatToolsInput) {
  return {
    createArtifact: tool({
      description:
        'Create a new artifact document (text or code) for this conversation and stream its content to the artifact panel.',
      inputSchema: z.object({
        title: z.string().min(1).max(200),
        kind: z.enum(['text', 'code']),
        instructions: z.string().min(1).max(4000).optional(),
      }),
      needsApproval: true,
      execute: async ({ title, kind, instructions }) => {
        const cleanedTitle = title.trim();
        const prompt = instructions?.trim() || `Create a ${kind} artifact titled "${cleanedTitle}".`;

        const artifact = await client.mutation(api.artifacts.createArtifact, {
          conversationId,
          title: cleanedTitle,
          kind,
        });

        writer.write({
          type: 'data-kind',
          data: artifact.kind,
          transient: true,
        });
        writer.write({
          type: 'data-id',
          data: artifact.id,
          transient: true,
        });
        writer.write({
          type: 'data-title',
          data: artifact.title,
          transient: true,
        });
        writer.write({
          type: 'data-clear',
          data: null,
          transient: true,
        });

        const content = await streamArtifactDraft({
          instructions: prompt,
          kind: artifact.kind,
          selectedChatModel,
          title: artifact.title,
          writer,
        });

        const savedArtifact = await client.mutation(api.artifacts.appendArtifactVersion, {
          artifactId: artifact.id,
          content,
          changeSummary: 'Initial draft generated by assistant',
        });

        writer.write({
          type: 'data-finish',
          data: {
            artifactId: artifact.id,
            version: savedArtifact.version,
          },
          transient: true,
        });

        return {
          artifactId: artifact.id,
          title: artifact.title,
          kind: artifact.kind,
          version: savedArtifact.version,
        };
      },
    }),
    updateArtifact: tool({
      description:
        'Update an existing artifact using the provided instructions and stream the revised content to the artifact panel.',
      inputSchema: z.object({
        artifactId: z.string().min(1),
        description: z.string().min(1).max(4000),
      }),
      needsApproval: true,
      execute: async ({ artifactId, description }) => {
        const artifact = await client.query(api.artifacts.getArtifact, {
          artifactId: artifactId as Id<'artifacts'>,
        });

        if (!artifact || artifact.conversationId !== conversationId) {
          return {
            error: 'Artifact not found',
          };
        }

        writer.write({
          type: 'data-kind',
          data: artifact.kind,
          transient: true,
        });
        writer.write({
          type: 'data-id',
          data: artifact.id,
          transient: true,
        });
        writer.write({
          type: 'data-title',
          data: artifact.title,
          transient: true,
        });
        writer.write({
          type: 'data-clear',
          data: null,
          transient: true,
        });

        const content = await streamArtifactDraft({
          currentContent: artifact.content ?? '',
          instructions: description.trim(),
          kind: artifact.kind,
          selectedChatModel,
          title: artifact.title,
          writer,
        });

        const savedArtifact = await client.mutation(api.artifacts.appendArtifactVersion, {
          artifactId: artifact.id,
          content,
          changeSummary: description.trim(),
        });

        writer.write({
          type: 'data-finish',
          data: {
            artifactId: artifact.id,
            version: savedArtifact.version,
          },
          transient: true,
        });

        return {
          artifactId: artifact.id,
          title: artifact.title,
          kind: artifact.kind,
          version: savedArtifact.version,
        };
      },
    }),
    getArtifactContext: tool({
      description:
        'Fetch the latest content for an existing artifact in this conversation to ground follow-up analysis.',
      inputSchema: z.object({
        artifactId: z.string().min(1),
      }),
      execute: async ({ artifactId }) => {
        const artifact = await client.query(api.artifacts.getArtifact, {
          artifactId: artifactId as Id<'artifacts'>,
        });

        if (!artifact || artifact.conversationId !== conversationId) {
          return {
            error: 'Artifact not found',
          };
        }

        return {
          artifactId: artifact.id,
          title: artifact.title,
          kind: artifact.kind,
          latestVersion: artifact.latestVersion,
          content: artifact.content ?? '',
        };
      },
    }),
  };
}

export function buildChatTools(input: BuildChatToolsInput) {
  const { client, conversationId } = input;
  const artifactToolsEnabled = process.env.AI_ARTIFACTS_V1_ENABLED
    ? process.env.AI_ARTIFACTS_V1_ENABLED === 'true'
    : true;

  const baseTools = {
    getPolicySummary: tool({
      description: 'Get a compact summary of the current enabled policy rules for this organization.',
      inputSchema: z.object({
        limit: z.number().int().min(1).max(50).optional(),
      }),
      execute: async ({ limit }) => {
        const rules = await client.query(api.governance.listPolicyRules, {
          limit: limit ?? 20,
        });

        const enabledRules = rules.filter((rule) => rule.enabled);
        return {
          totalRules: rules.length,
          enabledRules: enabledRules.length,
          rules: enabledRules.map((rule) => ({
            id: rule.id,
            name: rule.name,
            mode: rule.mode,
          })),
        };
      },
    }),
    getRecentAuditEvents: tool({
      description: 'Get recent audit events from this organization for troubleshooting and governance context.',
      inputSchema: z.object({
        limit: z.number().int().min(1).max(100).optional(),
      }),
      execute: async ({ limit }) => {
        const events = await client.query(api.governance.listRecentAuditEvents, {
          limit: limit ?? 20,
        });

        return {
          count: events.length,
          events,
        };
      },
    }),
    createApprovalDraft: tool({
      description: 'Create a draft approval request for a governance action.',
      inputSchema: z.object({
        action: z.string().min(1).max(120),
        resource: z.string().min(1).max(120),
        justification: z.string().min(1).max(1000).optional(),
      }),
      needsApproval: true,
      execute: async ({ action, resource, justification }) => {
        const approval = await client.mutation(api.governance.createApprovalRequestDraft, {
          conversationId,
          action,
          resource,
          justification,
        });

        return {
          approvalRequestId: approval.id,
          status: approval.status,
          action: approval.action,
          resource: approval.resource,
        };
      },
    }),
  };

  if (!artifactToolsEnabled) {
    return baseTools;
  }

  return {
    ...baseTools,
    ...createArtifactTools(input),
  };
}
